@page "/Tools/Info/PolicyListActivity"
@using LibMatrix.EventTypes.Spec.State.Policy
@using System.Diagnostics
@using System.Reflection
@using ArcaneLibs.Extensions
@using LibMatrix
@using LibMatrix.EventTypes
@using LibMatrix.RoomTypes
@using LibMatrix.EventTypes.Common
@using LibMatrix.Filters

@* <ActivityGraph Data="TestData"/> *@
@if (RoomData.Count == 0) {
    <p>Loading...</p>
}
else
    foreach (var room in RoomData) {
        <h3>@room.Key</h3>
        @foreach (var year in room.Value.OrderBy(x => x.Key)) {
            <span>@year.Key</span>
            <ActivityGraph Data="@year.Value" GlobalMax="MaxValue" RLabel="removed" GLabel="new" BLabel="updated policies"/>
        }
    }


@code {
    public AuthenticatedHomeserverGeneric? Homeserver { get; set; }
    public List<GenericRoom> FilteredRooms = new();

    public Dictionary<DateOnly, ActivityGraph.RGB> TestData { get; set; } = new();

    public ActivityGraph.RGB MaxValue { get; set; } = new() {
        R = 255, G = 255, B = 255
    };

    public Dictionary<string, Dictionary<int, Dictionary<DateOnly, ActivityGraph.RGB>>> RoomData { get; set; } = new();

    protected override async Task OnInitializedAsync() {
        var sw = Stopwatch.StartNew();
        await base.OnInitializedAsync();
        Homeserver = (await sessionStore.GetCurrentHomeserver(navigateOnFailure: true))!;
        if (Homeserver is null) return;

        var rooms = await Homeserver.GetJoinedRooms();
        var roomFilterTasks = rooms.Select(async room => {
            var type = await room.GetRoomType();
            if (type == "support.feline.policy.lists.msc.v1") {
                Console.WriteLine($"{room.RoomId} is policy list by type");
                return room;
            }
            else if (await room.GetStateOrNullAsync<MjolnirShortcodeEventContent>(MjolnirShortcodeEventContent.EventId) is not null) {
                Console.WriteLine($"{room.RoomId} is policy list by shortcode");
                return room;
            }

            return null;
        }).ToList();
        var filteredRooms = await Task.WhenAll(roomFilterTasks);
        FilteredRooms.AddRange(filteredRooms.Where(x => x is not null).Cast<GenericRoom>());
        Console.WriteLine($"Filtered {FilteredRooms.Count} rooms in {sw.ElapsedMilliseconds}ms");

        var roomTasks = FilteredRooms.Select(FetchRoomHistory).ToList();
        await Task.WhenAll(roomTasks);

        Console.WriteLine($"Max value is {MaxValue.R} {MaxValue.G} {MaxValue.B}");
        Console.WriteLine($"Filtered {FilteredRooms.Count} rooms in {sw.ElapsedMilliseconds}ms");
    }

    public async Task FetchRoomHistory(GenericRoom room) {
        var roomName = await room.GetNameOrFallbackAsync();
        if (string.IsNullOrWhiteSpace(roomName)) roomName = room.RoomId;
        if (!RoomData.ContainsKey(roomName)) {
            RoomData[roomName] = new();
        }

        //use timeline
        var types = MatrixEvent.KnownEventTypes.Where(x => x.IsAssignableTo(typeof(PolicyRuleEventContent)));
        var filter = new SyncFilter.EventFilter(types: types.SelectMany(x => x.GetCustomAttributes<MatrixEventAttribute>().Select(y => y.EventName)).ToList());
        var timeline = room.GetManyMessagesAsync(limit: int.MaxValue, chunkSize: 2500, filter: filter.ToJson(indent: false, ignoreNull: true));
        await foreach (var response in timeline) {
            Console.WriteLine($"Got {response.State.Count} state, {response.Chunk.Count} timeline");
            if (response.State.Count != 0) throw new Exception("Why the hell did we receive state events?");
            foreach (var message in response.Chunk) {
                if (!message.MappedType.IsAssignableTo(typeof(PolicyRuleEventContent))) continue;
                //OriginServerTs to datetime
                var dt = DateTimeOffset.FromUnixTimeMilliseconds(message.OriginServerTs!.Value).DateTime;
                var date = new DateOnly(dt.Year, dt.Month, dt.Day);
                if (!RoomData[roomName].ContainsKey(date.Year)) {
                    RoomData[roomName][date.Year] = new();
                }

                if (!RoomData[roomName][date.Year].ContainsKey(date)) {
                    // Console.WriteLine($"Adding {date} to {roomName}");
                    RoomData[roomName][date.Year][date] = new();
                }

                var rgb = RoomData[roomName][date.Year][date];
                if (message.RawContent is { Count: 0 } or null) rgb.R++;
                else if (!message.Unsigned?.ContainsKey("replaces_state") ?? true) rgb.G++;
                else rgb.B++;
                RoomData[roomName][date.Year][date] = rgb;
            }
        }

        var max = RoomData.SelectMany(x => x.Value.Values).Aggregate(new ActivityGraph.RGB(), (current, next) => new() {
            R = Math.Max(current.R, next.Average(x => x.Value.R)),
            G = Math.Max(current.G, next.Average(x => x.Value.G)),
            B = Math.Max(current.B, next.Average(x => x.Value.B))
        });
        MaxValue = new ActivityGraph.RGB(
            r: Math.Max(max.R, Math.Max(max.G, max.B)),
            g: Math.Max(max.R, Math.Max(max.G, max.B)),
            b: Math.Max(max.R, Math.Max(max.G, max.B)));
        Console.WriteLine($"Max value is {MaxValue.R} {MaxValue.G} {MaxValue.B}");
        StateHasChanged();
        await Task.Yield();
    }

    private readonly struct StateEventEntry {
        public required DateTime Timestamp { get; init; }
        public required StateEventTransition State { get; init; }
        public required MatrixEventResponse Event { get; init; }
        public required MatrixEventResponse? Previous { get; init; }

        public void Deconstruct(out StateEventTransition transition, out MatrixEventResponse evt, out MatrixEventResponse? prev) {
            transition = State;
            evt = Event;
            prev = Previous;
        }
    }

    private enum StateEventTransition : byte {
        None,
        Add,
        Update,
        Remove
    }

}