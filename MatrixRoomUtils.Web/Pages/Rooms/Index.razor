@page "/Rooms"
@using LibMatrix.Filters
@using LibMatrix.Helpers
@using LibMatrix.EventTypes.Spec.State
@using LibMatrix
@using LibMatrix.Homeservers
@using ArcaneLibs.Extensions
@using LibMatrix.Extensions
@using LibMatrix.Responses
@using System.Collections.ObjectModel
@inject ILogger<Index> logger
<h3>Room list</h3>

<p>@Status</p>
<p>@Status2</p>
@* @if (RenderContents) { *@
<RoomList Rooms="Rooms" GlobalProfile="@GlobalProfile" @bind-StillFetching="RenderContents"></RoomList>
@* } *@
@* else { *@
@* <RoomList Rooms="Rooms" GlobalProfile="@GlobalProfile" StillFetching="true"></RoomList> *@
@* } *@

@code {
    private ObservableCollection<RoomInfo> Rooms { get; } = new();
    private ProfileResponseEventContent GlobalProfile { get; set; }

    private AuthenticatedHomeserverGeneric? Homeserver { get; set; }

    private static SyncFilter filter = new() {
        AccountData = new SyncFilter.EventFilter {
            NotTypes = new List<string> { "*" },
            Limit = 1
        },
        Presence = new SyncFilter.EventFilter {
            NotTypes = new List<string> { "*" },
            Limit = 1
        },
        Room = new SyncFilter.RoomFilter {
            AccountData = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            },
            Ephemeral = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            },
            State = new SyncFilter.RoomFilter.StateFilter {
                Types = new List<string> {
                    "m.room.name",
                    "m.room.avatar",
                    "m.room.create",
                    "org.matrix.mjolnir.shortcode",
                    "m.room.power_levels",
                }
            },
            Timeline = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            }
        }
    };

    private static SyncFilter profileUpdateFilter = new() {
        AccountData = new SyncFilter.EventFilter {
            NotTypes = new List<string> { "*" },
            Limit = 1
        },
        Presence = new SyncFilter.EventFilter {
            NotTypes = new List<string> { "*" },
            Limit = 1
        },
        Room = new SyncFilter.RoomFilter {
            AccountData = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            },
            Ephemeral = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            },
            State = new SyncFilter.RoomFilter.StateFilter {
                Types = new List<string> {
                    "m.room.member"
                },
                Senders = new()
            },
            Timeline = new SyncFilter.RoomFilter.StateFilter {
                NotTypes = new List<string> { "*" },
                Limit = 1
            }
        }
    };

    protected override async Task OnInitializedAsync() {
        Homeserver = await MRUStorage.GetCurrentSessionOrNavigate();
        if (Homeserver is null) return;
        var rooms = await Homeserver.GetJoinedRooms();
        foreach (var room in rooms) {
            Rooms.Add(new(){Room = room});
        }
        
        GlobalProfile = await Homeserver.GetProfileAsync(Homeserver.WhoAmI.UserId);

        var syncHelper = new SyncHelper(Homeserver, logger) {
            Timeout = 10000,
            Filter = filter
        };
        profileUpdateFilter.Room.State.Senders.Add(Homeserver.WhoAmI.UserId);
        var profileSyncHelper = new SyncHelper(Homeserver, logger) {
            Timeout = 10000,
            Filter = profileUpdateFilter
        };
        RunSyncLoop(syncHelper);
        RunSyncLoop(profileSyncHelper);
        RunQueueProcessor();
        await base.OnInitializedAsync();
    }

    private async Task RunQueueProcessor() {
        while (true) {
            try {
                if (queue.Count == 0) {
                    while (queue.Count == 0) {
                        Console.WriteLine("Queue is empty, waiting...");
                        await Task.Delay(2500);
                    }
                    Console.WriteLine("Queue no longer empty!");
                }
                if (queue.TryDequeue(out var queueEntry)) {
                    var (roomId, roomData) = queueEntry;
                    Console.WriteLine($"Dequeued room {roomId}");
                    RoomInfo room;
                    
                    if (Rooms.Any(x => x.Room.RoomId == roomId)) {
                        room = Rooms.First(x => x.Room.RoomId == roomId);
                        Console.WriteLine($"QueueWorker: {roomId} already known with {room.StateEvents?.Count ?? 0} state events");
                    }
                    else {
                        Console.WriteLine($"QueueWorker: encountered new room {roomId}!");
                        room = new RoomInfo() {
                            Room = Homeserver.GetRoom(roomId)
                        };
                        Rooms.Add(room);
                    }
                    
                    if (room.StateEvents is null) {
                        Console.WriteLine($"QueueWorker: {roomId} does not have state events on record?");
                        throw new InvalidDataException("Somehow this is null???");
                    }
                    if (roomData.State?.Events is {Count: >0 })
                        room.StateEvents.MergeStateEventLists(roomData.State.Events);
                    else {
                        Console.WriteLine($"QueueWorker: could not merge state for {room.Room.RoomId} as new data contains no state events!");
                    }
                    if (Random.Shared.Next(101) < 20 || true) {
                        Status = $"Got {Rooms.Count} rooms so far! {queue.Count} entries in processing queue...";
                    }
                    RenderContents |= queue.Count == 0;
                    await Task.Delay(RenderContents ? 25 : 25);
                }
                else {
                    Console.WriteLine("Failed to dequeue item");
                }
            }
            catch (Exception e) {
                Console.WriteLine("QueueWorker exception: " + e);
            }
        }
    }

    private bool RenderContents { get; set; } = false;

    private string _status;

    public string Status {
        get => _status;
        set {
            _status = value;
            StateHasChanged();
        }
    }

    private string _status2;

    public string Status2 {
        get => _status2;
        set {
            _status2 = value;
            StateHasChanged();
        }
    }

    private Queue<KeyValuePair<string, SyncResponse.RoomsDataStructure.JoinedRoomDataStructure>> queue = new();

    private async Task RunSyncLoop(SyncHelper syncHelper) {
        Status = "Initial syncing...";
        Console.WriteLine("starting sync");

        var syncs = syncHelper.EnumerateSyncAsync();
        await foreach (var sync in syncs) {
            Console.WriteLine("trying sync");
            if (sync is null) continue;

            Status = $"Got sync with {sync.Rooms?.Join?.Count ?? 0} room updates, next batch: {sync.NextBatch}!";
            if (sync?.Rooms?.Join != null)
                foreach (var joinedRoom in sync.Rooms.Join)
                    if ( /*joinedRoom.Value.AccountData?.Events?.Count > 0 ||*/ joinedRoom.Value.State?.Events?.Count > 0) {
                        joinedRoom.Value.State.Events.RemoveAll(x => x.Type == "m.room.member" && x.StateKey != Homeserver.WhoAmI?.UserId);
                        // We can't trust servers to give us what we ask for, and this ruins performance
                        // Thanks, Conduit.
                        joinedRoom.Value.State.Events.RemoveAll(x => filter.Room?.State?.Types?.Contains(x.Type) ?? false);
                        if(filter.Room?.State?.NotSenders?.Any() ?? false)
                            joinedRoom.Value.State.Events.RemoveAll(x => filter.Room?.State?.NotSenders?.Contains(x.Sender) ?? false);
                        
                        queue.Enqueue(joinedRoom);
                    }

            Status = $"Got {Rooms.Count} rooms so far! {queue.Count} entries in processing queue... " +
                     $"{sync?.Rooms?.Join?.Count ?? 0} new updates!";

            Status2 = $"Next batch: {sync.NextBatch}";
        }
    }

}