@page "/Rooms/{RoomId}/Policies"
@using LibMatrix
@using ArcaneLibs.Extensions
@using LibMatrix.EventTypes.Spec.State.Policy
@using System.Diagnostics
@using LibMatrix.RoomTypes
@using System.Collections.Frozen
@using System.Reflection
@using ArcaneLibs.Attributes
@using LibMatrix.EventTypes
@using LibMatrix.EventTypes.Interop.Draupnir
@using LibMatrix.EventTypes.Spec.State.RoomInfo
@using SpawnDev.BlazorJS.WebWorkers
@using MatrixUtils.Web.Pages.Rooms.PolicyListComponents
@inject WebWorkerService WebWorkerService
@inject ILogger<PolicyList> logger

@if (!IsInitialised) {
    <p>Connecting to homeserver...</p>
}
else {
    <PolicyListEditorHeader Room="@Room" ReloadStateAsync="@(() => LoadStateAsync(true))"></PolicyListEditorHeader>
    @if (Loading) {
        <p>Loading...</p>
    }
    // else if (PolicyEventsByType is not { Count: > 0 }) {
    @* <p>No policies yet</p> *@
    // }
    else {
        var renderSw = Stopwatch.StartNew();
        var renderTotalSw = Stopwatch.StartNew();
        @foreach (var value in PolicyCollections.Values.OrderByDescending(x => x.TotalCount)) {
            <p>
                @value.ActivePolicies.Count active,
                @value.RemovedPolicies.Count removed
                (@value.TotalCount total)
                @value.Name.ToLower()
            </p>
        }

        // logger.LogInformation($"Rendered header in {renderSw.GetElapsedAndRestart()}");

        // var renderSw2 = Stopwatch.StartNew();
        // IOrderedEnumerable<Type> policiesByType = KnownPolicyTypes.Where(t => GetPolicyEventsByType(t).Count > 0).OrderByDescending(t => GetPolicyEventsByType(t).Count);
        // logger.LogInformation($"Ordered policy types by count in {renderSw2.GetElapsedAndRestart()}");

        foreach (var collection in PolicyCollections.Values.OrderByDescending(x => x.ActivePolicies.Count)) {
            <PolicyListCategoryComponent PolicyCollection="@collection" Room="@Room"></PolicyListCategoryComponent>
        }

        // foreach (var type in policiesByType) {
        @* foreach (var type in (List<Type>) []) { *@
        @*     <details> *@
        @*         <summary> *@
        @*             <span> *@
        @*                 @($"{GetPolicyTypeName(type)}: {GetPolicyEventsByType(type).Count} policies") *@
        @*             </span> *@
        @*             <hr style="margin: revert;"/> *@
        @*         </summary> *@
        @*         <table class="table table-striped table-hover table-bordered align-middle"> *@
        @*             @{ *@
        @*                 var renderSw3 = Stopwatch.StartNew(); *@
        @*                 var policies = GetValidPolicyEventsByType(type); *@
        @*                 var invalidPolicies = GetInvalidPolicyEventsByType(type); *@
        @*                 // enumerate all properties with friendly name *@
        @*                 var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance) *@
        @*                     .Where(x => (x.GetFriendlyNameOrNull() ?? x.GetJsonPropertyNameOrNull()) is not null) *@
        @*                     .Where(x => x.GetCustomAttribute<TableHideAttribute>() is null) *@
        @*                     .ToFrozenSet(); *@
        @*                 var propNames = props.Select(x => x.GetFriendlyNameOrNull() ?? x.GetJsonPropertyName()!).ToFrozenSet(); *@
        @* *@
        @*                 var proxySafeProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance) *@
        @*                     .Where(x => props.Any(y => y.Name == x.Name)) *@
        @*                     .ToFrozenSet(); *@
        @*                 logger.LogInformation($"{proxySafeProps?.Count} proxy safe props found in {policies.FirstOrDefault()?.TypedContent?.GetType()}"); *@
        @*                 logger.LogInformation($"Filtered policies and got properties in {renderSw3.GetElapsedAndRestart()}"); *@
        @*             } *@
        @*             <thead> *@
        @*                 <tr> *@
        @*                     @foreach (var name in propNames) { *@
        @*                         <th>@name</th> *@
        @*                     } *@
        @*                     <th>Actions</th> *@
        @*                 </tr> *@
        @*             </thead> *@
        @*             <tbody> *@
        @*                 @foreach (var policy in policies.OrderBy(x => x.RawContent?["entity"]?.GetValue<string>())) { *@
        @*                     <PolicyListRowComponent PolicyInfo="@policy" Room="@Room"></PolicyListRowComponent> *@
        @*                 } *@
        @*             </tbody> *@
        @*         </table> *@
        @*         <details> *@
        @*             <summary> *@
        @*                 <u> *@
        @*                     @("Invalid " + GetPolicyTypeName(type).ToLower()) *@
        @*                 </u> *@
        @*             </summary> *@
        @*             <table class="table table-striped table-hover"> *@
        @*                 <thead> *@
        @*                     <tr> *@
        @*                         <th>State key</th> *@
        @*                         <th>Json contents</th> *@
        @*                     </tr> *@
        @*                 </thead> *@
        @*                 <tbody> *@
        @*                     @foreach (var policy in invalidPolicies) { *@
        @*                         <tr> *@
        @*                             <td>@policy.StateKey</td> *@
        @*                             <td> *@
        @*                                 <pre>@policy.RawContent.ToJson(true, false)</pre> *@
        @*                             </td> *@
        @*                         </tr> *@
        @*                     } *@
        @*                 </tbody> *@
        @*             </table> *@
        @*         </details> *@
        @*     </details> *@
        // }

        // logger.LogInformation($"Rendered policies in {renderSw.GetElapsedAndRestart()}");
        logger.LogInformation($"Rendered in {renderTotalSw.Elapsed}");
    }
}

@code {

#if DEBUG
    private const bool Debug = true;
#else
    private const bool Debug = false;
#endif

    private bool IsInitialised { get; set; } = false;
    private bool Loading { get; set; } = true;

    [Parameter]
    public required string RoomId { get; set; }

    private Dictionary<Type, List<StateEventResponse>> PolicyEventsByType { get; set; } = new();

    public StateEventResponse? ServerPolicyToMakePermanent {
        get;
        set {
            field = value;
            StateHasChanged();
        }
    }

    private AuthenticatedHomeserverGeneric Homeserver { get; set; } = null!;
    private GenericRoom Room { get; set; } = null!;
    private RoomPowerLevelEventContent PowerLevels { get; set; } = null!;
    public bool CurrentUserIsDraupnir { get; set; }

    public Dictionary<StateEventResponse, int> ActiveKicks { get; set; } = [];

    protected override async Task OnInitializedAsync() {
        var sw = Stopwatch.StartNew();
        await base.OnInitializedAsync();
        Homeserver = (await sessionStore.GetCurrentHomeserver(navigateOnFailure: true))!;
        if (Homeserver is null) return;
        Room = Homeserver.GetRoom(RoomId!);
        IsInitialised = true;
        StateHasChanged();
        await Task.WhenAll(
            Task.Run(async () => { PowerLevels = (await Room.GetPowerLevelsAsync())!; }),
            Task.Run(async () => { CurrentUserIsDraupnir = (await Homeserver.GetAccountDataOrNullAsync<object>(DraupnirProtectedRoomsData.EventId)) is not null; })
        );
        StateHasChanged();
        await LoadStateAsync(firstLoad: true);
        Loading = false;
        logger.LogInformation($"Policy list editor initialized in {sw.Elapsed}!");
    }

    private async Task LoadStateAsync(bool firstLoad = false) {
        var sw = Stopwatch.StartNew();
        // Loading = true;
        // var states = Room.GetFullStateAsync();
        var states = await Room.GetFullStateAsListAsync();
        // PolicyEventsByType.Clear();

        logger.LogInformation($"LoadStatesAsync: Loaded state in {sw.Elapsed}");

        foreach (var type in KnownPolicyTypes) {
            if (!PolicyCollections.ContainsKey(type)) {
                var filterPropSw = Stopwatch.StartNew();
                // enumerate all properties with friendly name
                var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(x => (x.GetFriendlyNameOrNull() ?? x.GetJsonPropertyNameOrNull()) is not null)
                    .Where(x => x.GetCustomAttribute<TableHideAttribute>() is null)
                    .ToFrozenSet();

                var proxySafeProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(x => props.Any(y => y.Name == x.Name))
                    .ToFrozenDictionary(x => x.GetFriendlyNameOrNull() ?? x.GetJsonPropertyName(), x => x);
                logger.LogInformation($"{proxySafeProps?.Count} proxy safe props found in {type.FullName} ({filterPropSw.Elapsed})");
                PolicyCollections.Add(type, new() {
                    Name = type.GetFriendlyNamePluralOrNull() ?? type.FullName ?? type.Name,
                    ActivePolicies = [],
                    RemovedPolicies = [],
                    PropertiesToDisplay = proxySafeProps
                });
            }
        }

        var count = 0;
        var parseSw = Stopwatch.StartNew();
        foreach (var evt in states) {
            var sw2 = Stopwatch.StartNew();
            var mappedType = evt.MappedType;
            logger.LogInformation($"Processing state #{count++:000000} {evt.Type} @ {sw.Elapsed} (took {parseSw.Elapsed:c} so far to process)");
            if (!mappedType.IsAssignableTo(typeof(PolicyRuleEventContent))) continue;

            var collection = PolicyCollections[mappedType];

            var key = (evt.Type, evt.StateKey!);
            var policyInfo = new PolicyCollection.PolicyInfo {
                Policy = evt,
                MadeRedundantBy = []
            };
            if (evt.RawContent is null or { Count: 0 } || string.IsNullOrWhiteSpace(evt.RawContent?["recommendation"]?.GetValue<string>())) {
                collection.ActivePolicies.Remove(key);
                if (!collection.RemovedPolicies.TryAdd(key, policyInfo)) {
                    if (StateEvent.Equals(collection.RemovedPolicies[key].Policy, evt)) continue;
                    collection.RemovedPolicies[key] = policyInfo;
                }
            }
            else {
                collection.RemovedPolicies.Remove(key);
                if (!collection.ActivePolicies.TryAdd(key, policyInfo)) {
                    if (StateEvent.Equals(collection.ActivePolicies[key].Policy, evt)) continue;
                    collection.ActivePolicies[key] = policyInfo;
                }
            }
        }

        logger.LogInformation($"LoadStatesAsync: Processed state in {sw.Elapsed}");
        foreach (var collection in PolicyCollections) {
            logger.LogInformation($"Policy collection {collection.Key.FullName} has {collection.Value.ActivePolicies.Count} active and {collection.Value.RemovedPolicies.Count} removed policies.");
        }

        logger.LogInformation("LoadStatesAsync: Scanning for redundant policies...");

        Loading = false;
        var allPolicies = PolicyCollections.Values
            .SelectMany(x => x.ActivePolicies.Values)
            .Select(x => (x, x.Policy.TypedContent as PolicyRuleEventContent))
            .ToList();
        var wildcardPolicies = allPolicies
            .Where(x => x.Item2!.IsGlobRule() || x.Item2 is ServerPolicyRuleEventContent)
            .ToList();
        Console.WriteLine($"Got {allPolicies.Count} total policies, {wildcardPolicies.Count} wildcard policies.");
        int i = 0;
        int hits = 0;
        int redundant = 0;
        int duplicates = 0;
        foreach (var policy in allPolicies) {
            if (policy.Item2 is null) continue;
            var matchingPolicies = wildcardPolicies
                .Where(x =>
                    !StateEvent.TypeKeyPairMatches(policy.x.Policy, x.x.Policy)
                    && x.Item2!.EntityMatches(policy.Item2.Entity!)
                )
                .ToList();

            if (matchingPolicies.Count > 0) {
                logger.LogInformation($"{i} Got {matchingPolicies.Count} hits for {policy.x.Policy.RawContent.ToJson()}: {matchingPolicies.Select(x => x.x.Policy.RawContent).ToJson()}");
                foreach (var match in matchingPolicies) {
                    policy.x.MadeRedundantBy.Add(match.x.Policy);
                }

                hits++;
                redundant += matchingPolicies.Count;

                if (hits % 5 == 0)
                    StateHasChanged();
            }
            else logger.LogInformation("Sleeping...");
            await Task.Delay(1);
            i++;
        }

        i = 0;
        foreach (var policy in allPolicies) {
            if (policy.Item2 is null) continue;
            var matchingPolicies = allPolicies
                .Where(x =>
                    !StateEvent.TypeKeyPairMatches(policy.x.Policy, x.x.Policy)
                    && x.Item2!.Entity == policy.Item2.Entity!
                )
                .ToList();

            if (matchingPolicies.Count > 0) {
                logger.LogInformation($"{i} Got {matchingPolicies.Count} duplicates for {policy.x.Policy.RawContent.ToJson()}: {matchingPolicies.Select(x => x.x.Policy.RawContent).ToJson()}");
                foreach (var match in matchingPolicies) {
                    policy.x.MadeRedundantBy.Add(match.x.Policy);
                }

                hits++;
                redundant += matchingPolicies.Count;

                if (hits % 5 == 0)
                    StateHasChanged();
            }
            else logger.LogInformation("Sleeping...");
            await Task.Delay(1);
            i++;
        }

        logger.LogInformation($"LoadStatesAsync: Found {hits} ({redundant} redundant, {duplicates} duplicates) redundant policies in {sw.Elapsed}");
        StateHasChanged();
    }

    // the old one:
    private async Task LoadStatesAsync(bool firstLoad = false) {
        await LoadStateAsync(firstLoad);
        return;
        var sw = Stopwatch.StartNew();
        Loading = true;
        // var states = Room.GetFullStateAsync();
        var states = await Room.GetFullStateAsListAsync();
        // PolicyEventsByType.Clear();

        logger.LogInformation($"LoadStatesAsync: Loaded state in {sw.Elapsed}");

        foreach (var type in KnownPolicyTypes) {
            if (!PolicyEventsByType.ContainsKey(type))
                PolicyEventsByType.Add(type, new List
                    <StateEventResponse>(16000));
        }

        int count = 0;

        foreach (var state in states) {
            var _spsw = Stopwatch.StartNew();
            TimeSpan e1, e2, e3, e4, e5, e6, t;
            if (!state.MappedType.IsAssignableTo(typeof(PolicyRuleEventContent))) continue;
            e1 = _spsw.Elapsed;
            var targetPolicies = PolicyEventsByType[state.MappedType];
            e2 = _spsw.Elapsed;
            if (!firstLoad && targetPolicies.FirstOrDefault(x => StateEvent.TypeKeyPairMatches(x, state)) is { } evt) {
                e3 = _spsw.Elapsed;
                if (StateEvent.Equals(evt, state)) {
                    if (count % 100 == 0) {
                        await Task.Delay(10);
                        await Task.Yield();
                    }

                    e4 = _spsw.Elapsed;
                    logger.LogInformation($"[E] LoadStatesAsync: Processed state #{count++:000000} {state.Type} @ {sw.Elapsed} (e1={e1:c}, e2={e2:c}, e3={e3:c}, e4={e4:c}, e5={TimeSpan.Zero:c},t={_spsw.Elapsed:c})");
                    continue;
                }

                e4 = _spsw.Elapsed;
                targetPolicies.Remove(evt);
                e5 = _spsw.Elapsed;
                targetPolicies.Add(state);
                e6 = _spsw.Elapsed;
                t = _spsw.Elapsed;
                logger.LogInformation($"[M] LoadStatesAsync: Processed state #{count++:000000} {state.Type} @ {sw.Elapsed} (e1={e1:c}, e2={e2:c}, e3={e3:c}, e4={e4:c}, e5={e5:c}, e6={e6:c},t={t:c})");
            }
            else {
                targetPolicies.Add(state);
                t = _spsw.Elapsed;
                logger.LogInformation($"[N] LoadStatesAsync: Processed state #{count++:000000} {state.Type} @ {sw.Elapsed} (e1={e1:c}, e2={e2:c}, e3={TimeSpan.Zero:c}, e4={TimeSpan.Zero:c}, e5={TimeSpan.Zero:c}, e6={TimeSpan.Zero:c}, t={t:c})");
            }

            // await Task.Delay(10);
            // await Task.Yield();
        }

        logger.LogInformation($"LoadStatesAsync: Processed state in {sw.Elapsed}");

        Loading = false;
        StateHasChanged();
        await Task.Delay(10);
        await Task.Yield();
        logger.LogInformation($"LoadStatesAsync: yield finished in {sw.Elapsed}");
    }

    private List<StateEventResponse> GetPolicyEventsByType(Type type) => PolicyEventsByType.ContainsKey(type) ? PolicyEventsByType[type] : [];

    // private List<StateEventResponse> GetValidPolicyEventsByType(Type type) => GetPolicyEventsByType(type)
    //     .Where(x => !string.IsNullOrWhiteSpace(x.RawContent?["recommendation"]?.GetValue<string>())).ToList();
    //
    // private List<StateEventResponse> GetInvalidPolicyEventsByType(Type type) => GetPolicyEventsByType(type)
    //     .Where(x => x.RawContent is { Count: > 0 } && string.IsNullOrWhiteSpace(x.RawContent?["recommendation"]?.GetValue<string>())).ToList();
    //
    // private List<StateEventResponse> GetRemovedPolicyEventsByType(Type type) => GetPolicyEventsByType(type)
    //     .Where(x => x.RawContent is null or { Count: 0 }).ToList();

    private string? GetPolicyTypeNameOrNull(Type type) => type.GetFriendlyNamePluralOrNull()
                                                          ?? type.GetCustomAttributes<MatrixEventAttribute>()
                                                              .FirstOrDefault(x => !string.IsNullOrWhiteSpace(x.EventName))?.EventName;

    private string GetPolicyTypeName(Type type) => GetPolicyTypeNameOrNull(type) ?? type.Name;

    private static FrozenSet<Type> KnownPolicyTypes = StateEvent.KnownStateEventTypes.Where(x => x.IsAssignableTo(typeof(PolicyRuleEventContent))).ToFrozenSet();

    // event types, unnamed
    private static Dictionary<string, Type> PolicyTypes = KnownPolicyTypes
        .ToDictionary(x => x.GetCustomAttributes<MatrixEventAttribute>().First(y => !string.IsNullOrWhiteSpace(y.EventName)).EventName, x => x);

    private static Dictionary<Type, string[]> PolicyTypeIds = KnownPolicyTypes
        .ToDictionary(x => x, x => x.GetCustomAttributes<MatrixEventAttribute>().Select(y => y.EventName).ToArray());

    Dictionary<Type, PolicyCollection> PolicyCollections { get; set; } = new();

    public struct PolicyCollection {
        public required string Name { get; init; }
        public int TotalCount => ActivePolicies.Count + RemovedPolicies.Count;

        public required Dictionary<(string Type, string StateKey), PolicyInfo> ActivePolicies { get; set; }

        // public Dictionary<(string Type, string StateKey), StateEventResponse> InvalidPolicies { get; set; }
        public required Dictionary<(string Type, string StateKey), PolicyInfo> RemovedPolicies { get; set; }
        public required FrozenDictionary<string, PropertyInfo> PropertiesToDisplay { get; set; }

        public struct PolicyInfo {
            public required StateEventResponse Policy { get; init; }
            public required List<StateEventResponse> MadeRedundantBy { get; set; }
        }
    }

    // private struct PolicyStats {
    // public int Active { get; set; }
    // public int Invalid { get; set; }
    // public int Removed { get; set; }
    // }

}